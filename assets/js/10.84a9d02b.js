(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{281:function(e,t,a){"use strict";a.r(t);var n=a(14),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"面试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试"}},[e._v("#")]),e._v(" 面试")]),e._v(" "),t("h2",{attrs:{id:"mobx和redux区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mobx和redux区别"}},[e._v("#")]),e._v(" mobx和redux区别")]),e._v(" "),t("p",[e._v("1.redux状态是只读的，不能直接修改它；mobx状态可变的，可以直接修改"),t("br"),e._v("\n2.mobx相对来说状态管理更加简单，学习成本低"),t("br"),e._v("\n3.mobx面向对象编程，使用observer绑定状态，观察这个状态，一旦变更就自动更新；redux函数式编程，reducer就是一个存函数，接受输出然后输出新状态，每次都是返回一个新的数据")]),e._v(" "),t("h2",{attrs:{id:"vue和react的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue和react的区别"}},[e._v("#")]),e._v(" vue和react的区别")]),e._v(" "),t("p",[e._v("vue是mvvm，双向绑定，他监听的是一个数据变化然后去改变ui；\nreact是单向数据流，讲求一个函数式编程，一个函数代表一个ui组件，数据不可变。状态变更时，记录新树和旧树的差异，最后把差异更新到真正的dom中")]),e._v(" "),t("h2",{attrs:{id:"tcp三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[e._v("#")]),e._v(" TCP三次握手")]),e._v(" "),t("p",[e._v("1、客户端发送syn包到服务器，等待服务器确认接收。2、服务器确认接收syn包并确认客户的syn，并发送回来一个syn+ack的包给客户端。3、客户端确认接收服务器的syn+ack包，并向服务器发送确认包ack，二者相互建立联系后，完成tcp三次握手。四次握手就是中间多了一层 等待服务器再一次响应回复相关数据的过程")]),e._v(" "),t("h2",{attrs:{id:"链判断运算符-optional-chaining"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链判断运算符-optional-chaining"}},[e._v("#")]),e._v(" 链判断运算符(Optional Chaining)")]),e._v(" "),t("p",[e._v("ES2020链判断运算符，使用a?.c?.b代替a && a.c && a.c.b")]),e._v(" "),t("h2",{attrs:{id:"构造函数包含return"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数包含return"}},[e._v("#")]),e._v(" 构造函数包含return")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function A(){\n  this.x=3\n  return 'ok'; //如果返回基本数据类型，仍然会返回新对象实列\n}\nvar b = new A()\nb.x; //3\n----------------\nfunction A(){\n  this.x=3\n  return {x: 4}; //如果返回引用类型（对象、数组、函数），返回值就是return的值\n}\nvar b = new A()\nb.x; //4\n")])])]),t("h2",{attrs:{id:"js实现深拷贝的几种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js实现深拷贝的几种方法"}},[e._v("#")]),e._v(" js实现深拷贝的几种方法")]),e._v(" "),t("p",[e._v("1.使用es6")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var a=[1,2,3]\nvar b=[...a];\n")])])]),t("p",[e._v("2.使用concat()方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var a=[1,2,3]\nvar c=[];\nvar b=c.concat(a);\n")])])]),t("p",[e._v("3.使用递归")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function deep(obj) {\n  //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝\n  var objClone = Array.isArray(obj) ? [] : {};\n  //进行深拷贝的不能为空，并且是对象或者是\n  if (obj && typeof obj === "object") {\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {//只遍历自身属性\n        if (obj[key] && typeof obj[key] === "object") {\n          objClone[key] = deep(obj[key]);\n        } else {\n          objClone[key] = obj[key];\n        }\n      }\n    }\n  }\n  return objClone;\n}\n')])])]),e._v(" "),t("h2",{attrs:{id:"常用状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用状态码"}},[e._v("#")]),e._v(" 常用状态码")]),e._v(" "),t("ul",[t("li",[e._v("1xx（请求处理中）")]),e._v(" "),t("li",[e._v("2xx（请求处理完毕）\n"),t("ul",[t("li",[e._v("200（请求成功）")])])]),e._v(" "),t("li",[e._v("3xx（重定向）\n"),t("ul",[t("li",[e._v("301（永久重定向）")]),e._v(" "),t("li",[e._v("302（临时重定向）")]),e._v(" "),t("li",[e._v("304（请求资源没有变化，使用缓存）")])])]),e._v(" "),t("li",[e._v("4xx（客户端请求错误）\n"),t("ul",[t("li",[e._v("400（请求参数错误）")]),e._v(" "),t("li",[e._v("401（没有权限访问，一般表示未登陆）")]),e._v(" "),t("li",[e._v("403（禁止访问，一般表示权限不够，需要更高的权限）")]),e._v(" "),t("li",[e._v("404（请求的资源不存在）")])])]),e._v(" "),t("li",[e._v("5xx（服务器端错误）\n"),t("ul",[t("li",[e._v("500（服务器内部出错）")]),e._v(" "),t("li",[e._v("503（服务器在维护）")])])])]),e._v(" "),t("h2",{attrs:{id:"eventloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" Eventloop")]),e._v(" "),t("p",[e._v("在node中,其中有3个阶段,他们的执行顺序："),t("br"),e._v("\ntimes -> poll（停留，一直等到有任务才往下一个阶段） -> check"),t("br"),e._v("\n对应api:"),t("br"),e._v("\ntimes -> setTimeout/setInterval"),t("br"),e._v("\ncheck -> setImmediate"),t("br"),e._v("\n当前阶段后面执行api："),t("br"),e._v("\nnextTick -> 如：times(setTimeout)中写nextTick,执行顺序就是time -> nextTick -> poll"),t("br"),e._v("\npromise.then(fn) -> then后立即把fn放入当前队列后面"),t("br"),e._v("\nawait同promise，resolve后放入队列")]),e._v(" "),t("p",[e._v("在chrome中，2个阶段："),t("br"),e._v("\n宏任务（一会执行）MacroTask"),t("br"),e._v("\n微任务（马上执行）MicroTask"),t("br"),e._v("\n对应api:"),t("br"),e._v("\n宏任务 -> setTimeout/setInterval"),t("br"),e._v("\n微任务 -> promise.then(fn)（then后立即把fn放入当前队列后面）/ await转promise"),t("br"),e._v("\n注: new Promise(fn),这个fn是立即执行的，不放进任何阶段")]),e._v(" "),t("h2",{attrs:{id:"react-diff-原理-就是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-原理-就是一个函数"}},[e._v("#")]),e._v(" react diff 原理：(就是一个函数)")]),e._v(" "),t("p",[e._v("使用tree diff将新旧两棵树逐层对比，找出那些节点需要更新，如果节点是组件使用component diff，如果是标签使用element diff"),t("br"),e._v("\ncomponent diff：如果不同组件，直接删除替换，相同只更新属性"),t("br"),e._v("\nelement diff：不同标签直接删除替换，相同只更新属性"),t("br"),e._v("\nkey作用，来标识一个组件，来判断是选择删除还是移动操作，比如，a-b组件，当只是位置换成b-a,如果有添加key值，那只进行位置交换")])])}),[],!1,null,null,null);t.default=r.exports}}]);